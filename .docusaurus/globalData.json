{
  "docusaurus-plugin-google-gtag": {
    "default": {
      "trackingID": [
        "G-S4SD5NXWXF"
      ],
      "anonymizeIP": true,
      "id": "default"
    }
  },
  "docusaurus-plugin-content-docs": {
    "default": {
      "path": "/docs",
      "versions": [
        {
          "name": "current",
          "label": "Next",
          "isLast": true,
          "path": "/docs",
          "mainDocId": "skill/introduction",
          "docs": [
            {
              "id": "diary/introduction",
              "path": "/docs/diary"
            },
            {
              "id": "project_group/introduction",
              "path": "/docs/project_group",
              "sidebar": "project_group"
            },
            {
              "id": "project_group/motor_ctrl/AxDrive-L/AxDrive-L_hardware_design_report",
              "path": "/docs/AxDrive-L_hardware_design_report",
              "sidebar": "project_group"
            },
            {
              "id": "project_group/motor_ctrl/AxDrive-L/AxDrive-L_software_design_report",
              "path": "/docs/AxDrive-L_software_design_report",
              "sidebar": "project_group"
            },
            {
              "id": "project_group/motor_ctrl/AxDrive-L/AxDrive-L_user_manual",
              "path": "/docs/AxDrive-L_user_manual",
              "sidebar": "project_group"
            },
            {
              "id": "skill/C/C_Basic/C_array",
              "path": "/docs/C_array",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_basic_syntax",
              "path": "/docs/C_basic_syntax",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_brief_introduction",
              "path": "/docs/C_brief_introduction",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_character_string",
              "path": "/docs/C_character_string",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_control_flow",
              "path": "/docs/C_control_flow",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_datetype",
              "path": "/docs/C_datetype",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_environment_settings",
              "path": "/docs/C_environment_settings",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_function",
              "path": "/docs/C_function",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_function_order",
              "path": "/docs/C_function_order",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_keyword",
              "path": "/docs/C_keyword",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_memory",
              "path": "/docs/C_memory",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_operator",
              "path": "/docs/C_operator",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_other",
              "path": "/docs/C_other"
            },
            {
              "id": "skill/C/C_Basic/C_pointer",
              "path": "/docs/C_pointer",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_pointer_and_array",
              "path": "/docs/C_pointer_and_array",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_pointer_array_and_pointer_array",
              "path": "/docs/C_pointer_array_and_pointer_array",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_pointer_High_level_issues",
              "path": "/docs/C_pointer_High_level_issues",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_pretreatment",
              "path": "/docs/C_pretreatment",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_program_structure",
              "path": "/docs/C_program_structure",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_scope",
              "path": "/docs/C_scope",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_struct",
              "path": "/docs/C_struct",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_struct_size",
              "path": "/docs/C_struct_size",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_two_pointer",
              "path": "/docs/C_two_pointer",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_typedef",
              "path": "/docs/C_typedef",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_union_enum",
              "path": "/docs/C_union_enum",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Basic/C_variable_constant",
              "path": "/docs/C_variable_constant",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Data_Structure/binary_tree",
              "path": "/docs/binary_tree",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Data_Structure/data_structure",
              "path": "/docs/data_structure",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Data_Structure/double_linked_list",
              "path": "/docs/double_linked_list",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Data_Structure/inline_list",
              "path": "/docs/inline_list",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Data_Structure/linear_table",
              "path": "/docs/linear_table",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Data_Structure/queue",
              "path": "/docs/queue",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Data_Structure/single_linked_list",
              "path": "/docs/single_linked_list",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Data_Structure/singly_loop_linked_list",
              "path": "/docs/singly_loop_linked_list",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/C_Data_Structure/stack",
              "path": "/docs/stack",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/FILE_IO/dir",
              "path": "/docs/dir",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/FILE_IO/file",
              "path": "/docs/file",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/FILE_IO/standard_io",
              "path": "/docs/standard_io",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/FILE_IO/stat",
              "path": "/docs/stat",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/FILE_IO/system_io",
              "path": "/docs/system_io",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/Network/socket",
              "path": "/docs/socket",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/Network/tcp",
              "path": "/docs/tcp"
            },
            {
              "id": "skill/C/System/cond",
              "path": "/docs/cond",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/System/ipc",
              "path": "/docs/ipc",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/System/msg",
              "path": "/docs/msg",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/System/mutex",
              "path": "/docs/mutex",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/System/pipe",
              "path": "/docs/pipe",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/System/posix",
              "path": "/docs/posix",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/System/pro_api",
              "path": "/docs/pro_api",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/System/process",
              "path": "/docs/process",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/System/reen",
              "path": "/docs/reen",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/System/rwlock",
              "path": "/docs/rwlock",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/System/sem",
              "path": "/docs/sem",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/System/shm",
              "path": "/docs/shm",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/System/signal",
              "path": "/docs/signal",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/System/thread",
              "path": "/docs/thread",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/System/thread_pool",
              "path": "/docs/thread_pool",
              "sidebar": "skill"
            },
            {
              "id": "skill/C/System/thread_scheduling",
              "path": "/docs/thread_scheduling",
              "sidebar": "skill"
            },
            {
              "id": "skill/hardware/circuit/dc-dc",
              "path": "/docs/dc-dc"
            },
            {
              "id": "skill/hardware/component/Cap",
              "path": "/docs/Cap",
              "sidebar": "skill"
            },
            {
              "id": "skill/hardware/component/MOS",
              "path": "/docs/MOS",
              "sidebar": "skill"
            },
            {
              "id": "skill/hardware/component/Res",
              "path": "/docs/Res",
              "sidebar": "skill"
            },
            {
              "id": "skill/introduction",
              "path": "/docs/skill",
              "sidebar": "skill"
            },
            {
              "id": "skill/linux/Linux_introduction",
              "path": "/docs/Linux_introduction",
              "sidebar": "skill"
            },
            {
              "id": "skill/linux/Linux_shell",
              "path": "/docs/Linux_shell",
              "sidebar": "skill"
            },
            {
              "id": "skill/motor/pmsm/pmsm_motor",
              "path": "/docs/pmsm_motor",
              "sidebar": "skill"
            },
            {
              "id": "skill/other/look-up-port-and-kill-process",
              "path": "/docs/look-up-port-and-kill-process",
              "sidebar": "skill"
            },
            {
              "id": "tools/everything-quick-search-local-files",
              "path": "/docs/everything-quick-search-local-files",
              "sidebar": "tools"
            },
            {
              "id": "tools/introduction",
              "path": "/docs/tools",
              "sidebar": "tools"
            },
            {
              "id": "tools/vscode-config",
              "path": "/docs/vscode-config",
              "sidebar": "tools"
            },
            {
              "id": "tools/windows-custom-right-click-menu",
              "path": "/docs/windows-custom-right-click-menu",
              "sidebar": "tools"
            },
            {
              "id": "tools/windows-terminal-beautify",
              "path": "/docs/windows-terminal-beautify",
              "sidebar": "tools"
            },
            {
              "id": "/category/linux",
              "path": "/docs/category/linux",
              "sidebar": "skill"
            },
            {
              "id": "/category/c-语言",
              "path": "/docs/category/c-语言",
              "sidebar": "skill"
            },
            {
              "id": "/category/c-指针",
              "path": "/docs/category/c-指针",
              "sidebar": "skill"
            },
            {
              "id": "/category/c-复杂类型",
              "path": "/docs/category/c-复杂类型",
              "sidebar": "skill"
            },
            {
              "id": "/category/数据结构",
              "path": "/docs/category/数据结构",
              "sidebar": "skill"
            },
            {
              "id": "/category/io-编程技术",
              "path": "/docs/category/io-编程技术",
              "sidebar": "skill"
            },
            {
              "id": "/category/linux-系统编程",
              "path": "/docs/category/linux-系统编程",
              "sidebar": "skill"
            },
            {
              "id": "/category/linux-网络编程",
              "path": "/docs/category/linux-网络编程",
              "sidebar": "skill"
            },
            {
              "id": "/category/硬件基础",
              "path": "/docs/category/硬件基础",
              "sidebar": "skill"
            },
            {
              "id": "/category/元器件基础",
              "path": "/docs/category/元器件基础",
              "sidebar": "skill"
            },
            {
              "id": "/category/电机控制",
              "path": "/docs/category/电机控制",
              "sidebar": "skill"
            },
            {
              "id": "/category/杂项",
              "path": "/docs/category/杂项",
              "sidebar": "skill"
            },
            {
              "id": "/category/电机控制-1",
              "path": "/docs/category/电机控制-1",
              "sidebar": "project_group"
            },
            {
              "id": "/category/axdrive-l",
              "path": "/docs/category/axdrive-l",
              "sidebar": "project_group"
            }
          ],
          "draftIds": [],
          "sidebars": {
            "skill": {
              "link": {
                "path": "/docs/skill",
                "label": "skill/introduction"
              }
            },
            "tools": {
              "link": {
                "path": "/docs/tools",
                "label": "tools/introduction"
              }
            },
            "project_group": {
              "link": {
                "path": "/docs/project_group",
                "label": "project_group/introduction"
              }
            }
          }
        }
      ],
      "breadcrumbs": true
    }
  },
  "docusaurus-plugin-content-blog": {
    "default": {
      "blogs": [
        {
          "id": "/classic",
          "metadata": {
            "permalink": "/blog/classic",
            "editUrl": "https://github.com/disnox/blog/edit/main/blog/project/4. 100条经典C语言笔试题目.md",
            "source": "@site/blog/project/4. 100条经典C语言笔试题目.md",
            "title": "C 语言经典题目",
            "description": "C 语言经典题目",
            "date": "2022-12-17T00:00:00.000Z",
            "formattedDate": "2022年12月17日",
            "tags": [
              {
                "label": "C/C++",
                "permalink": "/blog/tags/c-c"
              },
              {
                "label": "exam",
                "permalink": "/blog/tags/exam"
              }
            ],
            "readingTime": 16.89,
            "hasTruncateMarker": true,
            "authors": [
              {
                "name": "📺尚宇",
                "title": "嵌入式 / 学生",
                "url": "https://github.com/disnox",
                "imageURL": "/img/logo.webp",
                "key": "disnox"
              }
            ],
            "frontMatter": {
              "slug": "/classic",
              "title": "C 语言经典题目",
              "date": "2022-12-17T00:00:00.000Z",
              "authors": "disnox",
              "tags": [
                "C/C++",
                "exam"
              ],
              "keywords": [
                "C/C++",
                "exam"
              ],
              "description": "C 语言经典题目",
              "image": "/img/blog/question.png",
              "sticky": 1
            },
            "unlisted": false,
            "nextItem": {
              "title": "单向链表创建线程池",
              "permalink": "/blog/thread_pool1"
            }
          },
          "content": "C 语言经典题目\n\n<!-- truncate -->\n\n### 1. 请填写 bool , float,  指针变量  与“零值”比较的 if  语句。\n\n 提示：这里“零值”可以是 0, 0.0 , FALSE 或者“空指针” 。例如 int  变量 n  与“零值”比较的 if  语句为： \n\n```jsx showLineNumbers\nif (n == 0)\nif (n !=0)\n```\n\n**（1）请写出 bool flag 与 “零值” 比较的 if 语句。**\n\n+ 标准答案：\n\n```jsx showLineNumbers\nif (flag)\t\nif (!flag)\n```\n\n+ 不良风格：\n\n```jsx showLineNumbers\nif (flag == TRUE)\t\nif (flag == 1)\t\nif (flag == FALSE)\t\t\nif (flag == 0)\n```\n\n**（2）请写出 float  x  与 “零值” 比较的 if  语句。**\n\n+ 标准答案：\n\n```jsx showLineNumbers\nconst float EPSINON = 0.0001;\nif (x >= -EPSINON)\n```\n\n**注意：不可将浮点变量用“==”或“！=”与数字比较，应该设法转化成 “>=” 或 “<=” 此类形式。** \n\n+ 错误写法\n\n```jsx showLineNumbers\nif (x == 0.0)\nif (x != 0.0)\n```\n\n**（3）请写出 char  *p  与“零值”比较的 if  语句。**\n\n+ 标准答案\n\n```jsx showLineNumbers\nif (p == NULL)\nif (p != NULL)\n```\n\n+ 错误写法\n\n```jsx showLineNumbers\nif (p == 0)\nif (p != 0)\nif (p)\n```\n\n### 2. 以下为Linux下的32位C程序，请计算sizeof的值。\n\n```jsx showLineNumbers\n(1) char str[] = “hello”;\t(2) char *p = str;\t(3) int n = 10;\n(4) void Func(char str[100]);\t(5) void *p = malloc(100);\n```\n\n**请计算：**\n\n```jsx showLineNumbers\n(1) sizeof (str) =  6;\t(2) sizeof(p) = 4;\t (3) sizeof(n) = 4;\n(4) sizeof (str) =  4;\t(5) sizeof(p) = 4;\n```\n\n### 3. long a=0x801010，a+5 = ？\n\n| **十六进制** |    **8**    |  **0**   |  **1**   |  **0**   |  **1**   |  **0**   |\n| :----------: | :---------: | :------: | :------: | :------: | :------: | :------: |\n|  **二进制**  |  **1000**   | **0000** | **0001** | **0000** | **0001** | **0000** |\n|  **十进制**  | **8388608** |  **0**   | **4096** |  **0**   |  **16**  |  **0**   |\n\n所以 a 的十进制为：**8392720**。\n\n```jsx showLineNumbers\na + 5 = 8392725;\n```\n\n### 4. 用变量 a 给出下面定义:\n\n1. 一个有10个指针的数组，该指针是指向一个整型数的;\n\n```jsx showLineNumbers\nint *a[10];\n```\n\n2. 一个指向有10个整型数数组的指针;\n\n```jsx showLineNumbers\nint (*a)[10];\n```\n\n3. 一个指向函数的指针，该函数有一个整型参数并返回一个整型数;\n\n```jsx showLineNumbers\nint (*a)(int);\n```\n\n4. 一个有10个指针的数组，该指针指向一个函数，该  \t函数有一个整型参数并返回一个整型数;\n\n```jsx showLineNumbers\nint (*a[10])(int);\n```\n\n### 5. 设有以下定义说明:\n\n```jsx showLineNumbers\ntypedef union {\n    long i; \t// 8\n    int k[5]; \t// 20\n    char c;\t\t// 1\n} DATE;\n\nstruct data { \n    int cat; \t// 4\n    DATE cow; \t// 20\n    double dog;\t// 8\n} too;\n\nDATE max;\t\t// 20\n```\n\n则语句 `printf(\"%d\",sizeof(struct date)+sizeof(max));` 的执行结果是：\\__52\\__\n\n### 6. 请问下面的代码有什么问题?\n\n```jsx showLineNumbers\nint main(int argc, char *argv[]) \n{\n\tchar a;\n\tchar *str=&a;\n\tstrcpy(str,\"hello\");\n\tprintf(str);\n\treturn 0;\n}\n```\n\n**没有为 str 分配内存空间，可能会发生异常。**\n\n### 7. 请问下面的代码有什么问题?\n\n```jsx showLineNumbers\nint main(int argc, char *argv[])\n{\n\tchar *s = \"AAA\";\n    printf(\"%s\", s);\n    s[0] = 'B';\n    printf(\"%s\", s);\n}\n```\n\n\"AAA\" 是字符串常量。s 是指针，指向这个字符串常量，所以应该这样声明 s : cosnt char* s=\"AAA\";然后又因为是常量，所以对是s[0]的赋值操作是不合法的。\n\n### 8.  int (*s[10])(int) 表示的是什么?\n\n`int (*s[10])(int)` 是函数指针数组，每个指针指向一个 `int func(int param)` 的函数。\n\n### 9. c 和 c++ 中的 struct 有什么不同？\n\nc 和 c++ 中 struct 的主要区别是 c 中的 struct 不可以含有成员函数，而 c++ 中的 struct 可以。\n\n### 10. 下面的代码会出现什么问题？\n\n```jsx showLineNumbers\nvoid getmemory(char *p)\n{\n\tp=(char *) malloc(100);\n\tstrcpy(p,“hello world”);\n}\nint main(int argc, char *argv[])\n{\n\tchar *str=NULL;\n\tgetmemory(str);\n\tprintf(“%s/n”,str);\n\tfree(str);\n\treturn 0;\n}\n```\n\n会导致程序崩溃，因为 getmemory 函数中的 malloc 不能返回动态内存， free(str) 的操作很危险。\n\n### 11. 下面的代码会出现什么问题？\n\n```jsx showLineNumbers\nchar szstr[10];\nstrcpy(szstr,\"0123456789\");\n```\n\n出现段错误，因为字符串的最后面还有 ‘\\0’ 结束符，上面的数组长度只有10，而字符串长度是11，所以数组越界。\n\n### 12. 数组和链表的区别？\n\n+ 数组：数据顺序存储，固定大小\n+ 链表：数据可以随机存储，大小可动态改变\n\n### 13. 下面的代码会出现什么问题，打印结果是什么？\n\n```jsx showLineNumbers\nvoid main(int argc, char *argv[])\n{\n\tchar aa[10];\n\tprintf(\"%d\", strlen(aa));\n    printf(\"%d\", sizeof(aa));\n}\n```\n\nstrlen(aa) 打印结果未知，因为数组 aa[10] 是局部变量，没有对它进行初始化，系统会默认赋一些垃圾值给它，所以直接使用 strlen 去计算它的长度是未知的。\n\nsizeof(aa) 的打印结果为10，sizeof 的使用和初始化没有关系，它会直接计算出这个数组的长度。\n\n### 14. 下面结构体的大小？\n\n```jsx showLineNumbers\nsruct  A {\n\tchar t:4;\t\t\t// 4位\n\tchar k:4;\t\t\t// 4位\n\tunsigned short i:8;\t// 8位 这里要偏移2字节保证4字节对齐\n\tunsigned long m;\t// 4位\n};\n```\n\n所以 sizeof(A) = 8；\n\n### 15. 下面结构体的大小？\n\n```jsx showLineNumbers\nstruct name1 {\n\tchar str;\t\t// 1\n\tshort x;\t\t// 2\t\t\n\tint num;\t\t// 4\n};\n```\n\n所以 sizeof(name1) = 8；\n\n### 16. 下面结构体的大小？\n\n```jsx showLineNumbers\nstruct name2 {\n\tchar str;\t\t// 1\n\tint num;\t\t// 4\n\tshort x;\t\t// 2\n};\n```\n\n所以 sizeof(name2) = 12；\n\n### 17. 下面的程序有什么错误？\n\n```jsx showLineNumbers\nwap( int* p1,int* p2 )\n{\n    int *p;\n    *p = *p1;\n    *p1 = *p2;\n    *p2 = *p;\n}\n```\n\n指针 p 没有赋初值，变成了野指针。\n\n### 18. c++ 的 struct 和 class 有什么不同？\n\nc++ 中 struct 和 class 的主要区别在于默认的存取权限不同，struct 默认为 public，而 class 默认为 private。\n\n### 19. (void \\*)ptr 和 (\\*(void\\*\\*))ptr的结果是否相同？其中ptr为同一个指针。\n\n```jsx showLineNumbers\n(void *)ptr 和 (*(void **))ptr值是相同的。\n```\n\n### 20. 怎么对地址 0x100000 赋值?\n\n```jsx showLineNumbers\n(unsigned int *)0x100000 = 1234;\n```\n\n**那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？**\n\n```jsx showLineNumbers\n首先要将 0x100000 强制转换成函数指针,即:\n(void (*)())0x100000\n然后再调用它:\n*((void (*)())0x100000)();\n```\n\n### 21. int a,b,c; 请写函数实现 c=a+b ,不可以改变数据类型，如将 c 改为long int，如何处理溢出问题\n\n```jsx showLineNumbers\nbool add (int a, int b,int *c)\n{\n\t*c = a+b;\n\treturn (a>0 && b>0 &&(*c<a || *c<b) || (a<0 && b<0&&(*c>a || *c>b)));\n}\n```\n\n### 22. 内存思考题，下面代码你能看出有什么问题？\n\n+ **示例1：运行 test 函数会出现什么问题？**\n\n```jsx showLineNumbers\nvoid getmemory(char *p)\n{\n    p = (char *)malloc(100);\n}\n\nvoid test(void)\n{\n\tchar *str = NULL;\n    getmemory(str);\n\tstrcpy(str, \"hello world\");\n\tprintf(\"%s\", str);\n}\n```\n\n程序崩溃，因为 getmemory 并不能传递动态内存，test 函数中的 str 一直都是 NULL 。所以strcpy(str,”hello world”) 将使程序崩溃。\n\n+ **示例2：运行 test 函数会出现什么问题？**\n\n```jsx showLineNumbers\nvoid *getmemory(void)\n{\n    char p[] = \"hello world\";\n    return p;\n}\n\nvoid test(void)\n{\n\tchar *str = NULL;\n    str = getmemory();\n\tprintf(\"%s\", str);\n}\n```\n\n可能输出是乱码。因为 getmemory 返回的是指向栈内存的指针，该指针的地址不是NULL，但其原先的内容已经被清除，新内容不可知。\n\n+ **示例3：运行 test 函数会出现什么问题？**\n\n```jsx showLineNumbers\nvoid getmemory(char **p, int num)\n{\n    *p = (char *)malloc(num);\n}\n\nvoid test(void)\n{\n\tchar *str = NULL;\n    getmemory(&str, 100);\n\tstrcpy(str, \"hello\");\n\tprintf(\"%s\", str);\n}\n```\n\n能够输出 hello，但是内存泄漏。\n\n+ **示例4：运行 test 函数会出现什么问题？**\n\n```jsx showLineNumbers\nvoid test(void)\n{\n\tchar *str = (char *)malloc(100);\n\tstrcpy(str, \"hello\");\n\tfree(str);\n\tif(str != NULL) {\n        strcpy(str, \"world\");\n        printf(\"%s\", str);\n    }\n}\n```\n\n篡改动态内存区的内容，后果难以预料非常危险。因为free(str)之后 str成为野指针，if（str ！= NULL）语句不起作用。\n\n### 27.  关键字volatile有什么含意? 并给出三个不同的例子。\n\n一个定义为 volatile 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。\n\n下面是volatile变量的几个例子： \n\n+ 并行设备的硬件寄存器（如：状态寄存器） 。\n+ 一个中断服务子程序中会访问到的非自动变量 (Non-automatic variables) 。\n+ 多线程应用中被几个任务共享的变量 。\n\n### 28. 编写下面要求的代码。\n\n嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为 0x67a9 的整型变量的值为 0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。\n\n```jsx showLineNumbers\nint *ptr; \nptr = (int *)0x67a9; \n*ptr = 0xaa55;\n```\n\n### 29. 头文件中的 ifndef/define/endif 是做什么的？\n\n防止该头文件被重复引用。  \n\n### 30. \\#include <filename.h\\> 和 \\#include  “filename.h” 有什么区别？\n\n+ 对于 \\#include  <filename.h\\> 来说编译器会从标准库路径开始搜索 filename.h 。\n+ 对于 \\#include  “filename.h” 来说编译器从用户的工作路径开始搜索 filename.h 。\n\n### 31. const  有什么用途？\n\n+ 可以定义 const  常量\n+ const 可以修饰函数的参数、返回值，甚至函数的定义体。\n+ 被 const 修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。  \n\n### 32.  static有什么用途？\n\n+ 限制变量的作用域（static全局变量）。\n+ 设置变量的存储域（static局部变量）。\n+ 修饰函数只对本文件可见。\n\n### 33. 堆栈溢出一般是由什么原因导致的？\n\n+ 没有回收垃圾资源。\n\n### 34. 如何引用一个已经定义过的全局变量？\n\n可以用引用头文件的方式，也可以用 extern 关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定那个变量写错了，那么在编译期间会报错，如果用 extern 方式引用时，假定犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。\n\n### 35. 全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？\n\n可以，在不同的 C 文件中以 static 形式来声明同名全局变量。可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个 C 文件中对此变量赋初值，此时连接不会出错。\n\n### 36. 队列和栈有什么区别？\n\n队列先进先出，栈先进后出。\n\n### 37. heap 与 stack 的差别。\n\n+ heap是堆，stack是栈。\n+ stack的空间由操作系统自动分配/释放，heap上的空间手动分配/释放。\n+ stack空间有限，heap是很大的自由存储区。\n+ C中的malloc函数分配的内存空间即在堆上,C++中对应的是new操作符。\n+ 程序在编译期对变量和函数分配内存都在栈上进行，且程序运行过程中函数调用时参数的传递也在栈上进行。\n\n### 38. 用宏定义写出swap（x，y），即交换两数。\n\n```jsx showLineNumbers\n#define swap(x, y) (x)=(x)+(y);(y)=(x)–(y);(x)=(x)–(y);\n```\n\n### 39. 写一个“标准”宏，这个宏输入两个参数并返回较小的一个。\n\n```jsx showLineNumbers\n#define Min(X, Y) ((X)>(Y)?(Y):(X))\t//结尾没有;\n```\n\n### 40. 带参宏与带参函数的区别？\n\n- 带参宏的执行效率要高于带参函数。因为带参宏的代码是在预处理阶段直接替换进程序代码中的，所以不需要在运行时调用函数和返回，所以带参宏的执行效率要高于带参函数。\n- 带参宏不检查数据类型。带参宏在预处理阶段进行替换，而不是在运行时进行调用，所以带参宏不会检查参数的数据类型。\n- 使用带参宏时传递了错误的参数类型，在编译时可能不会报错，但是在运行时会出现意想不到的错误。\n- 带参函数会在编译时检查参数的数据类型，因此在编译时就能发现错误。\n\n### 41. 关键字volatile有什么含意？\n\n提示编译器对象的值可能在编译器未监测到的情况下改变。\n\n### 42. 下面这个函数既然不会被其它函数调用，为什么要返回1？\n\n```jsx showLineNumbers\nint main(int argc, char *argv[])\n{\n\tint x=3;\n\tprintf(\"%d\",x);\n\treturn 1;\n}\n```\n\nmian 中，c 标准认为 0 表示成功，非 0 表示错误。具体的值是某中具体出错信息。\n\n### 43. 已知一个数组table，用一个宏定义，求出数据的元素个数。\n\n```jsx showLineNumbers\n#define NTBL(table) (sizeof(table)/sizeof(table[0]))\n```\n\n### 44. A.c 和B.c两个c文件中使用了两个相同名字的static变量,编译的时候会不会有问题?这两个static变量会保存到哪里（栈还是堆或者其他的）?\n\n+ static 修饰的全局变量，表明这个变量仅在本模块中有意义，不会影响其他模块。\n+ 他们都放在静态数据区，但是编译器对他们的命名是不同的。\n+ 如果要使变量在其他模块也有意义的话，需要使用extern关键字。\n\n### 45. static全局变量与普通的全局变量有什么区别？\n\n+ static全局变量只初使化一次，防止在其他文件单元中被引用。\n\n### 46. static局部变量和普通局部变量有什么区别?\n\n+ static局部变量只被初始化一次，下一次依据上一次结果值；\n\n### 47. static函数与普通函数有什么区别？\n\n+ static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝\n\n:::info 关于45-47的参考文章\n\n   全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。\n从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。\nstatic函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。\n\n:::\n\n### 48. 程序的局部变量存在于____中，全局变量存在于____中，动态申请数据存在于___中。\n\n+ 程序的局部变量存在于栈(stack)中，全局变量存在于静态数据区 中，动态申请数据存在于堆（heap）中。\n\n### 49. 什么是预编译，何时需要预编译?\n\n+ 总是使用在不经常改动的大型代码体。 \n+ 程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。\n\n### 50. 用两个栈实现一个队列的功能？要求给出算法和思路！\n\n:::info 思路\n\n设2个栈为A,B, 一开始均为空。\n\n入队：将新元素 push 入栈A;\n\n出队：\n\n+ 判断栈B是否为空；\n\n+ 如果不为空，则将栈A中所有元素依次pop出并push到栈B；\n\n+ 将栈B的栈顶元素pop出；\n\n:::\n\n### 51. 对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?\n\n+ C 用宏定义，C++ 用inline\n\n### 52. 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）\n\n```jsx showLineNumbers\n#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL \n```\n\n### 53. typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。\n\n+ **例如，思考一下下面的例子：**\n\n```jsx showLineNumbers\n#define dPS struct s * \ntypedef struct s * tPS; \n```\n\n**以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？ **\n\n这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。\n\n+ **思考下面的例子：**\n\n```jsx showLineNumbers\ndPS p1, p2;\t// struct s * p1, p2; \ntPS p3, p4;\n```\n\n上面的代码定义p1为一个指向结构的指针，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。\n\n### 54. 在 C++  程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”？\n\nC++ 语言支持函数重载，C 语言不支持函数重载。函数被 C++编译后在库中的名字与 C 语言的不同。\n\n假设某个函数的原型为：void foo(int x, int y); 该函数被 C 编译器编译后在库中的名字为_foo，而 C++编译器则会产生像\\_foo_int_int 之类的名字。 \n\nC++ 提供了 C 连接交换指定符号 extern“C”来解决名字匹配问题。 \n\n### 55. 请简述以下两个 for 循环的优缺点。\n\n+ 示例1：\n\n```jsx showLineNumbers\nfor (i=0; i<n; i++) {\n    if (condition)\n        DoSomething();\n    else\n        DoOthering();\n}\n```\n\n优点：程序简洁。\n\n缺点：多执行了 N-1 次逻辑判断，并且打断了循环的 “流水线” 作业，使得编译器不能对循环进行优化处理，降低了效率。\n\n+ 示例2：\n\n```jsx showLineNumbers\nif (condition) {\n    for (i=0; i<n; i++) \n        DoSomething();\n}\nelse {\n    for (i=0; i<n; i++) \n         DoOthering();\n}\n```\n\n优点：循环效率高。\n\n缺点：程序不简洁。\n\n### 56. 语句for( ；1 ；)有什么问题？它是什么意思？\n\n+ 死循环，和while(1)相同。\n\n### 57. do……while和while……do有什么区别？\n\n+ 前一个循环一遍再判断，后一个判断以后再循环。\n\n### 58. 请写出下列代码的输出内容\n\n```jsx showLineNumbers\n#include <stdio.h>\nint main(int argc, char *argv[])\n{\n\tint a,b,c,d;\n\ta=10;\n\tb=a++;\n\tc=++a;\n\td=10*a++;\n\tprintf(\"b，c，d：%d，%d，%d\"，b，c，d）;\n\treturn 0;\n}\n```\n\nb，c，d：10，12，120\n\n### 59. 下面代码 p1+5 跟 p2+5 等于多少？\n\n```jsx showLineNumbers\nunsigned char *p1;\nunsigned long *p2;\np1=(unsigned char *)0x801000;\np2=(unsigned long *)0x810000;    \n```\n\n+ 0x801005、0x810020\n\n### 60、请写出下列代码的输出内容\n\n```jsx showLineNumbers\n main()\n{\n\tint a[5]={1,2,3,4,5};\n\tint *ptr=(int *)(&a+1);\n\tprintf(“%d，%d”,*(a+1),*(ptr-1));\n}\n```\n\n2，5\n\n### 61. 请问下面程序有什么错误？\n\n```jsx showLineNumbers\nint a[60][250][1000], i, j, k;\nfor (k=0; k<=1000; k++)\n\tfor (j=0; j<250; j++)\n\t\tfor (i=0; i<60; i++)\na[i][j][k]=0;\n```\n\n需要将循环语句内外换一下才能对数组进行赋值。\n\n### 62. 以下是求一个数的平方的程序,请找出错误:\n```jsx showLineNumbers\n#define SQUARE(a)((a)*(a))\nint a=5;\nint b;\nb=SQUARE(a++);\n```\n\n宏在预编译时会以替换的形式展开，仅仅会替换。涉及到宏的地方，不要用++ --，标准中对此没有规定，因此最终结果将会依赖于不同的编译器。\n\n执行程序的答案可能是25、也有可能是36。\n\n### 63. 下面这段代码执行有什么问题？\n\n```jsx showLineNumbers\n#define Max_CB 500\nvoid LmiQueryCSmd(Struct MSgCB * pmsg)\n{\n\tunsigned char ucCmdNum;\n\t......  \n\tfor(ucCmdNum=0;ucCmdNum<Max_CB;ucCmdNum++)\n\t{\n\t\t......;\n\t}                                        \n}\n```\n\n程序会进入死循环 ，unsigned char 是无符号字符型它的范围是 0~255。\n\n### 64. 嵌入式系统中经常要用到无限循环，你怎么用C编写死循环。\n\n```jsx showLineNumbers\nwhile(1);\nfor(;;);\ndo ... while(1);\n```\n\n### 65. 下面程序输出结果是？\n\n```jsx showLineNumbers\nint sum(int a)\n{\n    auto int c = 0;\n    static int b = 3;\n    c += 1;\n    b += 2;\n    return(a+b+c);\n}\n\nvoid main(void)\n{\n    int i;\n    int a = 2;\n    for (i = 0;i < 5;i ++) {\n   \t\tPrintf(“%d”,sum(a));\n    }\n}\n```\n\n8，10，12，14，16\n\n<!-- truncate -->"
        },
        {
          "id": "/thread_pool1",
          "metadata": {
            "permalink": "/blog/thread_pool1",
            "editUrl": "https://github.com/disnox/blog/edit/main/blog/project/2. 单向链表创建线程池.md",
            "source": "@site/blog/project/2. 单向链表创建线程池.md",
            "title": "单向链表创建线程池",
            "description": "单向链表创建线程池",
            "date": "2022-12-16T00:00:00.000Z",
            "formattedDate": "2022年12月16日",
            "tags": [
              {
                "label": "C/C++",
                "permalink": "/blog/tags/c-c"
              },
              {
                "label": "Linux",
                "permalink": "/blog/tags/linux"
              }
            ],
            "readingTime": 8.083333333333334,
            "hasTruncateMarker": true,
            "authors": [
              {
                "name": "📺尚宇",
                "title": "嵌入式 / 学生",
                "url": "https://github.com/disnox",
                "imageURL": "/img/logo.webp",
                "key": "disnox"
              }
            ],
            "frontMatter": {
              "slug": "/thread_pool1",
              "title": "单向链表创建线程池",
              "date": "2022-12-16T00:00:00.000Z",
              "authors": "disnox",
              "tags": [
                "C/C++",
                "Linux"
              ],
              "keywords": [
                "C/C++",
                "Linux"
              ],
              "description": "单向链表创建线程池",
              "image": "/img/blog/blog.png",
              "sticky": 3
            },
            "unlisted": false,
            "prevItem": {
              "title": "C 语言经典题目",
              "permalink": "/blog/classic"
            },
            "nextItem": {
              "title": "内核链表创建线程池",
              "permalink": "/blog/thread_pool2"
            }
          },
          "content": "使用单向链表实现线程池的接口设计\n\n<!-- truncate -->\n\n## 1. 基础知识\n\n关于链表和线程的使用方法可以查看我的技术笔记：[数据结构](https://www.disnox.top/docs/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84) 和 [系统编程](https://www.disnox.top/docs/category/linux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B) ，在这两个页面都可以找到链表和线程的一些基础知识和使用示例。\n\n在 Linux 系统中，线程池是一种用于管理和调度线程的机制。它由一组可以复用的线程组成，这些线程被保存在线程池中，并等待分配任务。\n\n当一个新的任务到达时，线程池会从其中选择一个线程来执行该任务。如果所有线程都正在执行任务，则新任务将被放在队列中等待，直到有线程可用。\n\n使用线程池的优点包括：\n\n- 可以更有效地利用 CPU 资源，因为线程可以在任务之间复用。\n- 可以更容易地管理线程，因为所有线程都在线程池中。\n- 可以更容易地维护线程的数量，因为可以限制线程池的大小。\n\n线程池的实现原理可以参考这篇笔记：[线程池](https://www.disnox.top/docs/thread_pool)。\n\n下面我们来看看怎么通过单向链表跟线程的组合实现线程池。\n\n## 2. 线程池接口设计\n\n### 2.1 任务结构体\n\n+ 接口文档\n\n| 原型     | struct task                                                  |\n| -------- | ------------------------------------------------------------ |\n| 功能描述 | 任务节点，包含需要执行的函数及其参数，通过链表连成一个任务队列 |\n| 成员列表 | ***void \\*(\\*task)(void \\*arg);<br/>void \\*arg;<br/>struct task \\*next;*** |\n| 备注     | 任务队列最终是形成一条单向链表                               |\n\n+ 代码实现\n\n```jsx showLineNumbers\nstruct task {\t// 任务节点\n\tvoid *(*task)(void *arg);\n\tvoid *arg;\n\tstruct task *next;\n};\n```\n\n### 2.2 线程池结构体\n\n+ 接口文档\n\n| 原型     | thread_pool                                                  |\n| :------- | :----------------------------------------------------------- |\n| 功能描述 | 包含线程池的所有信息                                         |\n| 成员列表 | ***pthread_mutex_t lock;\t// 互斥锁，保护任务队列<br/>pthread_cond_t  cond;\t// 条件变量，同步所有线程<br/>struct task \\*task_list;\t  // 任务链队列指针<br/>pthread_t \\*tids;\t\t      // 线程ID存放位置<br/>unsigned waiting_tasks;\t// 任务链队列中等待的任务个数<br/>unsigned active_threads;// 当前活跃线程个数<br/>bool shutdown;\t\t\t// 线程池销毁标记*** |\n| 备注     | 活跃线程个数由用户自行定义，但至少包含一条活跃线程           |\n\n+ 代码实现\n\n```jsx showLineNumbers\ntypedef struct thread_pool {// 线程池\n\tpthread_mutex_t lock;\t// 互斥锁，保护任务队列\n\tpthread_cond_t  cond;\t// 条件变量，同步所有线程\n\tstruct task *task_list;\t// 任务链队列指针\n\tpthread_t *tids;\t\t// 线程ID存放位置\n\tunsigned waiting_tasks;\t// 任务链队列中等待的任务个数\n\tunsigned active_threads;// 当前活跃线程个数\n\tbool shutdown;\t\t\t// 线程池销毁标记\n}thread_pool;\n```\n\n### 2.3 线程池初始化\n\n+ 接口文档\n\n| 原型       | bool init_pool(thread_pool* pool, unsigned int threads_number); |\n| :--------- | :----------------------------------------------------------- |\n| 功能描述   | 创建一个新的线程池，包含threads_number个活跃线程             |\n| 参数       | pool: 线程池指针<br/>threads_number: 初始活跃线程个数(大于等于1) |\n| 返回值     | 成功返回 true ，失败返回 false                               |\n| 所在头文件 | thread_pool.h                                                |\n| 备注       | 线程池最少线程个数为1                                        |\n\n+ 代码实现\n\n```jsx showLineNumbers\nbool init_pool(thread_pool *pool, unsigned int threads_number)\n{\n\tpthread_mutex_init(&pool->lock, NULL);\t// 初始化互斥锁\n\tpthread_cond_init(&pool->cond, NULL);\t// 初始化条件变量\n\n\tpool->shutdown = false;\t// 初始化线程池销毁标记\n\tpool->task_list = malloc(sizeof(struct task));\t// 初始化任务队列\n\tpool->tids = malloc(sizeof(pthread_t) * MAX_ACTIVE_THREADS);\t// 初始化存放线程ID的数组\n\n\tif(pool->task_list == NULL || pool->tids == NULL)\n\t{\n\t\tperror(\"allocate memory error\");\n\t\treturn false;\n\t}\n\n\tpool->task_list->next = NULL;\t// 链表的下一个节点为空\n\n\tpool->waiting_tasks = 0;\t// 初始化任务队列中等待的任务个数\n\tpool->active_threads = threads_number;\t//初始化活跃线程个数\n\n\tint i;\n\t// 创建指定数目线程\n\tfor(i=0; i<pool->active_threads; i++) {\n\t\tif(pthread_create(&((pool->tids)[i]), NULL, routine, (void *)pool) != 0) {\n\t\t\tperror(\"create threads error\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n```\n\n### 2.4 投送任务\n\n+ 接口文档\n\n| 原型       | bool add_task(thread_pool \\*pool, void \\*(\\*do_task)(void \\*arg), void \\*arg); |\n| :--------- | :----------------------------------------------------------- |\n| 功能描述   | 往线程池投送任务                                             |\n| 参数       | pool: 线程池指针<br/>do_task: 投送至线程池的执行例程 <br/>arg: 执行例程do_task的参数，若该执行例程不需要参数可设置为NULL |\n| 返回值     | 成功返回true，失败返回false                                  |\n| 所在头文件 | thread_pool.h                                                |\n| 备注       | 任务队列中最大任务个数为 MAX_WAITING_TASKS                   |\n\n+ 代码实现\n\n```jsx showLineNumbers\nbool add_task(thread_pool *pool, void *(*task)(void *arg), void *arg)\n{\n\tstruct task *new_task = malloc(sizeof(struct task));\t// 新任务结点\n\n\tif(new_task == NULL) {\n\t\tperror(\"allocate memory error\");\n\t\treturn false;\n\t}\n\n\t// 初始化任务节点\n\tnew_task->task = task;\n\tnew_task->arg = arg;\n\tnew_task->next = NULL;\n\n\t// 加锁、超过最大任务\n\tpthread_mutex_lock(&pool->lock);\n\tif(pool->waiting_tasks >= MAX_WAITING_TASKS) {\n\t\tpthread_mutex_unlock(&pool->lock);\n\n\t\tfprintf(stderr, \"too many tasks.\\n\");\n\t\tfree(new_task);\n\n\t\treturn false;\n\t}\n\t\n\tstruct task *tmp = pool->task_list;\n\twhile(tmp->next != NULL)\n\t\ttmp = tmp->next;\n\n\ttmp->next = new_task;\t// 添加新的任务结点\n\tpool->waiting_tasks++;\n\n\t// 释放互斥锁，并唤醒其中一个阻塞在条件变量上的线程\n\tpthread_mutex_unlock(&pool->lock);\n\tpthread_cond_signal(&pool->cond);\n\n\treturn true;\n}\n```\n\n### 2.5 增加活跃线程\n\n+ 接口文档\n\n| 原型       | int add_thread(thread_pool*pool, unsigned int additional_threads); |\n| :--------- | :----------------------------------------------------------- |\n| 功能描述   | 增加线程池中活跃线程的个数                                   |\n| 参数       | pool: 需要增加线程的线程池指针<br/>additional_threads: 新增线程个数 |\n| 返回值     | >0: 实际新增线程个数<br/>-1: 失败                            |\n| 所在头文件 | thread_pool.h                                                |\n| 备注       | 增加的活跃线程的数量和之前初始化的线程数量不能大于 MAX_ACTIVE_THREADS |\n\n+ 代码实现\n\n```jsx showLineNumbers\nint add_thread(thread_pool *pool, unsigned int additional_threads)\n{\n\tif(additional_threads == 0)\n\t\treturn 0;\n\n\tunsigned total_threads = pool->active_threads + additional_threads;\n\n\tint i, actual_increment = 0;\t// 成功创建线程的个数\n\t// 循环创建若干指定数目的线程\n\tfor(i=pool->active_threads; i<total_threads && i<MAX_ACTIVE_THREADS; i++) {\n\t\tif(pthread_create(&((pool->tids)[i]), NULL, routine, (void *)pool) != 0) {\n\t\t\tperror(\"add threads error\");\n\n\t\t\tif(actual_increment == 0)\n\t\t\t\treturn -1;\n\n\t\t\tbreak;\n\t\t}\n\t\tactual_increment++; \n\t}\n\n\t// 更新线程池中的活跃线程个数\n\tpool->active_threads += actual_increment;\n\n\treturn actual_increment;\n}\n```\n\n### 2.6 删除线程\n\n+ 接口文档\n\n| 原型       | int remove_thread(thread_pool*pool, unsigned int removing_threads); |\n| :--------- | :----------------------------------------------------------- |\n| 功能描述   | 删除线程池中活跃线程的个数                                   |\n| 参数       | pool: 需要删除线程的线程池指针<br/>removing_threads: 要删除的线程个数，该参数设置为0时直接返回当前线程池线程总数，对线程池不造成任何其它影响 |\n| 返回值     | >0: 当前线程池剩余线程个数<br/>-1:失败                       |\n| 所在头文件 | thread_pool.h                                                |\n| 备注       | 1，线程池至少会存在1条活跃线程<br/>2，如果被删除的线程正在执行任务，则将等待其完成任务之后删除 |\n\n+ 代码实现\n\n```jsx showLineNumbers\nint remove_thread(thread_pool *pool, unsigned int removing_threads)\n{\n\tif(removing_threads == 0)\n\t\treturn pool->active_threads;\n\t\n\tint remain_threads = pool->active_threads - removing_threads;\n\tremain_threads = remain_threads > 0 ? remain_threads : 1;\n\n\tint i;\n\t// 循环地取消掉指定数目的线程\n\tfor(i=pool->active_threads-1; i>remain_threads-1; i--) {\n\t\terrno = pthread_cancel(pool->tids[i]);\n\t\tif(errno != 0)\n\t\t\tbreak;\n\t}\n\n\tif(i == pool->active_threads-1) {\n\t\treturn -1;\n\t} else {\n\t\tpool->active_threads = i+1;\n\t\treturn i+1;\n\t}\n\n    return 0;\n}\n```\n\n### 2.7 销毁线程池\n\n+ 接口文档\n\n| 原型       | bool destroy_pool(thread_pool \\*pool);                       |\n| :--------- | :----------------------------------------------------------- |\n| 功能描述   | 阻塞等待所有任务完成，然后立即销毁整个线程池，释放所有资源和内存 |\n| 参数       | pool:将要销毁的线程池                                        |\n| 返回值     | 成功返回true，失败返回false                                  |\n| 所在头文件 | thread_pool.h                                                |\n| 备注       | 无                                                           |\n\n+ 代码实现\n\n```jsx showLineNumbers\nbool destroy_pool(thread_pool *pool)\n{\n\tpool->shutdown = true;\t// 线程池的销毁标记\n\tpthread_cond_broadcast(&pool->cond);\t// 唤醒所有线程\n\n\tint i;\n\t// 等待所有线程退出\n\tfor(i=0; i<pool->active_threads; i++) {\n\t\terrno = pthread_join(pool->tids[i], NULL);\n\t\tif(errno != 0) {\n\t\t\tprintf(\"join tids[%d] error: %s\\n\", i, strerror(errno));\n\t\t} else {\n\t\t\tprintf(\"[%u] is joined\\n\", (unsigned)pool->tids[i]);\n\t\t}\n\t}\n\n\tfree(pool->task_list);\t// 释放资源\n\tfree(pool->tids);\t\t// 清空任务队列\n\tfree(pool);\t\t\t\t// 释放任务队列\n\n\treturn true;\n}\n```\n\n### 2.8 线程入口函数\n\n+ 用来执行任务的线程函数：\n\n```jsx showLineNumbers\nvoid *routine(void *arg)\n{\n\tthread_pool *pool = (thread_pool *)arg;\t//定义线程池结构体指针，拿到线程池的指针\n\tstruct task *p;\t//定义任务结构体指针，用来表示拿到的任务\n\n\t//不断的拿任务，执行\n\twhile(1) {\n\t\t// 访问任务队列前加锁，为防止取消后死锁，注册处理例程 handle\n\t\tpthread_cleanup_push(handler, (void *)&pool->lock);\t//防止死锁\n\t\tpthread_mutex_lock(&pool->lock);\t//加锁\n\n\t\t//如果任务队列为空并且线程池没有被销毁，线程进入条件变量等待队列睡眠\n\t\twhile(pool->waiting_tasks == 0 && !pool->shutdown) {\n\t\t\t//条件变量等待队列\n\t\t\tpthread_cond_wait(&pool->cond, &pool->lock);\t\n\t\t}\n\n\t\t//如果任务为空，线程池被销毁，则立即释放互斥锁并退出\n\t\tif(pool->waiting_tasks == 0 && pool->shutdown) {\n\t\t\tpthread_mutex_unlock(&pool->lock);\n\t\t\tpthread_exit(NULL);\n\t\t}\n\n\t\t//取走一个任务\n\t\tp = pool->task_list->next;\n\t\tpool->task_list->next = p->next;\n\t\tpool->waiting_tasks--;\t//任务数量减1\n\n\t\t//任务取走，解锁，并弹栈 handle（但不执行它）\n\t\tpthread_mutex_unlock(&pool->lock);\n\t\tpthread_cleanup_pop(0);\n\n\t\t//执行任务期间拒绝取消请求\n\t\tpthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);\n\t\t(p->task)(p->arg);\n\t\tpthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n\n\t\tfree(p);\t//释放资源\n\t}\n\n\tpthread_exit(NULL);\n}\n```\n\n+ 注册死锁处理函数\n\n```jsx showLineNumbers\nvoid handler(void *arg)\n{\n\t// 响应取消请求之后自动处理：释放互斥锁\n\tpthread_mutex_unlock((pthread_mutex_t *)arg);\n}\n```\n\n## 3. 使用示例\n\n```jsx showLineNumbers\n#include <stdio.h>\n#include \"thread_pool.h\"\n\nvoid *my_task(void *arg)\n{\n\tint n = *(int *)arg;\n\n\tprintf(\"[%u][%s] ==> job will be done in %d sec...\\n\", (unsigned)pthread_self(), __FUNCTION__, n);\n\n\tsleep(n);\n\n\tprintf(\"[%u][%s] ==> job done!\\n\", (unsigned)pthread_self(), __FUNCTION__);\n\n\treturn NULL;\n\n\t// pthread_exit(NULL);\n}\n\nvoid *count_time(void *arg)\n{\n\tint i = 0;\n\twhile(1) {\n\t\tsleep(1);\n\t\tprintf(\"sec: %d\\n\", ++i);\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tpthread_t a;\n\tpthread_create(&a, NULL, count_time, NULL);\n\n\t// 1.初始化一个带有2条线程的线程池\n\tthread_pool *pool = malloc(sizeof(thread_pool));\n\tinit_pool(pool, 1);\n\n\t// 2.投入3个任务\n\tstatic int temp1 = 1, temp2 = 2, temp3 = 3, temp4 = 4, temp5 = 5;\n\tprintf(\"throwing 3 tasks...\\n\");\n\tadd_task(pool, my_task, (void *)&temp1);\n\tadd_task(pool, my_task, (void *)&temp2);\n\tadd_task(pool, my_task, (void *)&temp3);\n  \n\t// 3.显示当前有多少条线程\n\tprintf(\"current thread number: %d\\n\", remove_thread(pool, 0));\n\t// sleep(9);\n\n\t// 4.再投入2个任务\n\tprintf(\"throwing another 2 tasks...\\n\");\n\tadd_task(pool, my_task, (void *)&temp4);\n\tadd_task(pool, my_task, (void *)&temp5);\n\n\t// 5.增加2条线程\n\tadd_thread(pool, 2);\n\tsleep(5);\n\n\t// 6.删除3条线程\n\tprintf(\"remove 3 threads from the pool...\\n\");\n\tprintf(\"current thread number: %d\\n\", remove_thread(pool, 3));\n\n\t// 7.销毁线程池\n\tdestroy_pool(pool);\n\n\treturn 0;\n}\n```\n\n## 4. 源码\n\n想要源码的话，不妨上我的[🍍GitHub](https://github.com/disnox/pool)看看吧！"
        },
        {
          "id": "/thread_pool2",
          "metadata": {
            "permalink": "/blog/thread_pool2",
            "editUrl": "https://github.com/disnox/blog/edit/main/blog/project/3. 内核链表创建线程池.md",
            "source": "@site/blog/project/3. 内核链表创建线程池.md",
            "title": "内核链表创建线程池",
            "description": "内核链表创建线程池",
            "date": "2022-12-16T00:00:00.000Z",
            "formattedDate": "2022年12月16日",
            "tags": [
              {
                "label": "C/C++",
                "permalink": "/blog/tags/c-c"
              },
              {
                "label": "Linux",
                "permalink": "/blog/tags/linux"
              }
            ],
            "readingTime": 8.566666666666666,
            "hasTruncateMarker": true,
            "authors": [
              {
                "name": "📺尚宇",
                "title": "嵌入式 / 学生",
                "url": "https://github.com/disnox",
                "imageURL": "/img/logo.webp",
                "key": "disnox"
              }
            ],
            "frontMatter": {
              "slug": "/thread_pool2",
              "title": "内核链表创建线程池",
              "date": "2022-12-16T00:00:00.000Z",
              "authors": "disnox",
              "tags": [
                "C/C++",
                "Linux"
              ],
              "keywords": [
                "C/C++",
                "Linux"
              ],
              "description": "内核链表创建线程池",
              "image": "/img/blog/blog.png",
              "sticky": 2
            },
            "unlisted": false,
            "prevItem": {
              "title": "单向链表创建线程池",
              "permalink": "/blog/thread_pool1"
            },
            "nextItem": {
              "title": "我为什么要写博客",
              "permalink": "/blog/blog_write"
            }
          },
          "content": "使用内核链表实现线程池的接口设计\n\n<!-- truncate -->\n\n## 1. 基础知识\n\n关于链表和线程的使用方法可以查看我的技术笔记：[数据结构](https://www.disnox.top/docs/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84) 和 [系统编程](https://www.disnox.top/docs/category/linux-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B) ，在这两个页面都可以找到链表和线程的一些基础知识和使用示例。\n\n在 Linux 系统中，线程池是一种用于管理和调度线程的机制。它由一组可以复用的线程组成，这些线程被保存在线程池中，并等待分配任务。\n\n当一个新的任务到达时，线程池会从其中选择一个线程来执行该任务。如果所有线程都正在执行任务，则新任务将被放在队列中等待，直到有线程可用。\n\n使用线程池的优点包括：\n\n- 可以更有效地利用 CPU 资源，因为线程可以在任务之间复用。\n- 可以更容易地管理线程，因为所有线程都在线程池中。\n- 可以更容易地维护线程的数量，因为可以限制线程池的大小。\n\n线程池的实现原理可以参考这篇笔记：[线程池](https://www.disnox.top/docs/thread_pool)。\n\n内核链表的使用方法可以参考这篇笔记：[内核链表](https://www.disnox.top/docs/inline_list)。\n\n下面我们来看看怎么通过内核链表跟线程的组合实现线程池。\n\n## 2. 线程池接口设计\n\n### 2.1 线程结构体\n\n+ 接口文档\n\n| 原型     | struct thread                                                |\n| -------- | ------------------------------------------------------------ |\n| 功能描述 | 线程节点，包含线程ID，通过内核链表连成一个线程队列，方便后续进行扩展 |\n| 成员列表 | ***pthread_t id;           // 线程 ID<br/>struct list_head list;  // 小结构体*** |\n| 备注     | 线程队列最终是形成一条内核链表                               |\n\n+ 代码实现\n\n```jsx showLineNumbers\n// 线程池中的线程\nstruct thread {\n    pthread_t id;           // 线程 ID\n    struct list_head list;  // 小结构体\n};\n```\n\n### 2.2 任务结构体\n\n+ 接口文档\n\n| 原型     | struct task                                                  |\n| -------- | ------------------------------------------------------------ |\n| 功能描述 | 任务节点，包含需要执行的函数及其参数，通过链表连成一个任务队列 |\n| 成员列表 | ***void \\*(\\*func)(void \\*arg);<br/>void \\*arg;<br/>struct list_head list;*** |\n| 备注     | 任务队列最终是形成一条内核链表                               |\n\n+ 代码实现\n\n```jsx showLineNumbers\n// 线程池中的任务\nstruct task {\n    void *(*func)(void *);   \t// 任务函数\n    void *arg;              \t// 任务函数的参数\n    struct list_head list;  \t// 小结构体\n};\n```\n\n### 2.3 线程池结构体\n\n+ 接口文档\n\n| 原型     | thread_pool                                                  |\n| :------- | :----------------------------------------------------------- |\n| 功能描述 | 包含线程池的所有信息                                         |\n| 成员列表 | ***struct list_head threads;  \t// 线程队列<br/>struct list_head queue;  \t// 任务队列<br/>pthread_mutex_t lock;   \t// 互斥锁<br/>pthread_cond_t cond;     \t// 条件变量<br/>unsigned active_threads;\t// 线程队列中的线程数量<br/>unsigned waiting_tasks;\t\t// 任务链队列中等待的任务个数<br/>bool shutdown;\t\t\t\t// 线程池销毁标记*** |\n| 备注     | 活跃线程个数由用户自行定义，但至少包含一条活跃线程           |\n\n+ 代码实现\n\n```jsx showLineNumbers\nstruct thread_pool {\n    struct list_head threads;  \t// 线程队列\n    struct list_head queue;  \t// 任务队列\n    pthread_mutex_t lock;   \t// 互斥锁\n    pthread_cond_t cond;     \t// 条件变量\n\tunsigned active_threads;\t// 线程队列中的线程数量\n\tunsigned waiting_tasks;\t\t// 任务链队列中等待的任务个数\n\tbool shutdown;\t\t\t\t// 线程池销毁标记\n};\n```\n\n### 2.4 线程池初始化\n\n+ 接口文档\n\n| 原型       | void thread_pool_init(struct thread_pool *pool, int num_threads) |\n| :--------- | :----------------------------------------------------------- |\n| 功能描述   | 创建一个新的线程池，包含 num_threads 个活跃线程              |\n| 参数       | pool: 线程池指针<br/>num_threads: 初始活跃线程个数(大于等于1) |\n| 返回值     | 无                                                           |\n| 所在头文件 | thread_pool.h                                                |\n| 备注       | 线程池最少线程个数为1，最大值不超过 MAX_ACTIVE_THREADS       |\n\n+ 代码实现\n\n```jsx showLineNumbers\nvoid thread_pool_init(struct thread_pool *pool, int num_threads)\n{\n    int i;\n\n    // 检查 num_threads 的值是否超过了最大值\n    if (num_threads > MAX_ACTIVE_THREADS) {\n        num_threads = MAX_ACTIVE_THREADS;\n    }\n\n\tpool->waiting_tasks = 0;\t\t\t\t//初始化任务队列中等待的任务个数\n\tpool->active_threads = num_threads;\t\t//初始化活跃线程个数\n\tpool->shutdown = false;\t\t\t\t\t//初始化线程池销毁标记\n\n    INIT_LIST_HEAD(&pool->threads);\t// 初始化线程队列\n    INIT_LIST_HEAD(&pool->queue);\t// 初始化任务队列\n\n\t// 是否初始化成功\n\tif (!list_empty(&pool->queue) || !list_empty(&pool->threads)) {\n\t\tfprintf(stderr, \"init fail.\\n\");\n\t\texit(1);\n\t}\n\n    pthread_mutex_init(&pool->lock, NULL);\n    pthread_cond_init(&pool->cond, NULL);\n\n    // 创建线程池中的线程\n    for (i = 0; i < num_threads; i++) {\n        struct thread *thread = (struct thread *)malloc(sizeof(struct thread));\n\n        INIT_LIST_HEAD(&thread->list);\n        // 使用 pthread_create 创建线程\n        int ret = pthread_create(&thread->id, NULL, thread_pool_main, pool);\n\t\tif (ret != 0) {\n\t\t\tperror(\"create threads error\");\n\t\t\texit(1);\n\t\t}\n\n        // 将新创建的线程添加到线程池中\n        list_add_tail(&thread->list, &pool->threads);\n    }\n}\n```\n\n### 2.5 投送任务\n\n+ 接口文档\n\n| 原型       | void thread_pool_add_task(struct thread_pool \\*pool, void \\*(\\*func)(void \\*), void \\*arg) |\n| :--------- | :----------------------------------------------------------- |\n| 功能描述   | 往线程池投送任务                                             |\n| 参数       | pool: 线程池指针<br/>func: 投送至线程池的执行例程 <br/>arg: 执行例程 func 的参数，若该执行例程不需要参数可设置为NULL |\n| 返回值     | 无                                                           |\n| 所在头文件 | thread_pool.h                                                |\n| 备注       | 任务队列中最大任务个数为 MAX_WAITING_TASKS                   |\n\n+ 代码实现\n\n```jsx showLineNumbers\nvoid thread_pool_add_task(struct thread_pool *pool, void *(*func)(void *), void *arg)\n{\n    // 分配内存给新任务\n    struct task *new_task = (struct task *) malloc(sizeof(struct task));\n\n\tif(new_task == NULL) {\n\t\tperror(\"allocate memory error\");\n\t\texit(1);\n\t}\n\n\t// 初始化任务节点\n    new_task->func = func;\n    new_task->arg = arg;\n\n    // 获取锁\n    pthread_mutex_lock(&pool->lock);\n\t// 超过最大任务\n\n\tif(pool->waiting_tasks >= MAX_WAITING_TASKS) {\n\t\tpthread_mutex_unlock(&pool->lock);\n\n\t\tfprintf(stderr, \"too many tasks.\\n\");\n\t\tfree(new_task);\n\n\t\texit(1);\n\t}\n\n    // 将新任务添加到任务队列的末尾\n    list_add_tail(&new_task->list, &pool->queue);\n\n\t// 新任务加一\n\tpool->waiting_tasks++;\n\n    // 唤醒一个线程，让它开始执行新任务\n    pthread_cond_signal(&pool->cond);\n\n    // 释放锁\n    pthread_mutex_unlock(&pool->lock);\n}\n```\n\n### 2.6 增加活跃线程\n\n+ 接口文档\n\n| 原型       | void thread_pool_add_thread(struct thread_pool \\*pool, int num_threads) |\n| :--------- | :----------------------------------------------------------- |\n| 功能描述   | 增加线程池中活跃线程的个数                                   |\n| 参数       | pool: 需要增加线程的线程池指针<br/>num_threads: 新增线程个数 |\n| 返回值     | 无                                                           |\n| 所在头文件 | thread_pool.h                                                |\n| 备注       | 增加的活跃线程的数量和之前初始化的线程数量不能大于 MAX_ACTIVE_THREADS |\n\n+ 代码实现\n\n```jsx showLineNumbers\nvoid thread_pool_add_thread(struct thread_pool *pool, int num_threads)\n{\n    int i;\n\n    // 检查 num_threads 的值是否超过了最大值\n    if (num_threads > MAX_ACTIVE_THREADS - pool->active_threads) {\n        num_threads = MAX_ACTIVE_THREADS - pool->active_threads;\n    }\n\n    // 创建新线程\n    for (i = 0; i < num_threads; i++) {\n        struct thread *thread = (struct thread *)malloc(sizeof(struct thread));\n\n        INIT_LIST_HEAD(&thread->list);\n        // 使用 pthread_create 创建线程\n        int ret = pthread_create(&thread->id, NULL, thread_pool_main, pool);\n\t\tif (ret != 0) {\n\t\t\tperror(\"create threads error\");\n\t\t\texit(1);\n\t\t}\n\n        // 将新创建的线程添加到线程池中\n        list_add_tail(&thread->list, &pool->threads);\n    }\n\n    // 更新线程池中的活跃线程数\n    pool->active_threads += num_threads;\n}\n```\n\n### 2.7 删除线程\n\n+ 接口文档\n\n| 原型       | void thread_pool_remove_thread(struct thread_pool \\*pool, int num_threads); |\n| :--------- | :----------------------------------------------------------- |\n| 功能描述   | 删除线程池中活跃线程的个数                                   |\n| 参数       | pool: 需要删除线程的线程池指针<br/>num_threads: 要删除的线程个数，该参数设置为0时直接返回当前线程池线程总数，对线程池不造成任何其它影响 |\n| 返回值     | 无                                                           |\n| 所在头文件 | thread_pool.h                                                |\n| 备注       | 1，线程池至少会存在1条活跃线程<br/>2，如果被删除的线程正在执行任务，则将等待其完成任务之后删除 |\n\n+ 代码实现\n\n```jsx showLineNumbers\nvoid thread_pool_remove_thread(struct thread_pool *pool, int num_threads)\n{\n    int i;\n    for (i = 0; i < num_threads; i++) {\n        // 从线程池中获取最后一个线程\n        struct thread *thread = list_last_entry(&pool->threads, struct thread, list);\n\n        // 使用 pthread_cancel 取消线程\n        int ret = pthread_cancel(thread->id);\n        if (ret != 0) {\n            fprintf(stderr, \"pthread_cancel failed: %s\\n\", strerror(ret));\n        }\n\n        // 检查线程是否正在执行任务\n        if (pool->waiting_tasks > 0) {\n            // 如果线程正在执行任务，则等待它完成\n            pthread_join(thread->id, NULL);\n        }\n\n        // 从线程池中删除线程\n        list_del(&thread->list);\n        free(thread);\n\n\t\t// 更新线程池中的线程数\n        pool->active_threads--;\n    }\n}\n```\n\n### 2.8 销毁线程池\n\n+ 接口文档\n\n| 原型       | void thread_pool_destroy(thread_pool \\*pool);                |\n| :--------- | :----------------------------------------------------------- |\n| 功能描述   | 阻塞等待所有任务完成，然后立即销毁整个线程池，释放所有资源和内存 |\n| 参数       | pool:将要销毁的线程池                                        |\n| 返回值     | 成功返回true，失败返回false                                  |\n| 所在头文件 | thread_pool.h                                                |\n| 备注       | 无                                                           |\n\n+ 代码实现\n\n```jsx showLineNumbers\nvoid thread_pool_destroy(struct thread_pool *pool)\n{\n\tpool->shutdown = true;\t//线程池的销毁标记\n\tpthread_cond_broadcast(&pool->cond);\t//唤醒所有线程\n\tint i;\n\t// 销毁线程池中的所有线程\n\tfor (i = 1; i <= pool->active_threads; i++) {\n\t\tstruct thread *thread = list_entry(pool->threads.next, struct thread, list);\n\n    \t// 使用 pthread_join 等待线程结束\n   \t\tint ret = pthread_join(thread->id, NULL);\n    \tif(ret != 0) {\n        \tprintf(\"join id[%d] error: %s\\n\", i, strerror(errno));\n    \t} else {\n        \tprintf(\"[%ld] is joined, i=%d\\n\", thread->id, i);\n    \t}\n   \t\t// 从线程池中删除已退出的线程\n    \tlist_del(&thread->list);\n    \tfree(thread);\n\t}\n\n\t// 重置任务队列\n\tINIT_LIST_HEAD(&pool->queue);\n\t// 销毁锁和条件变量\n\tpthread_mutex_destroy(&pool->lock);\n\tpthread_cond_destroy(&pool->cond);\n\n\t// 释放线程池占用的内存\n\t// free(pool);\t\t\t\n}\n```\n\n### 2.9 线程入口函数\n\n+ 用来执行任务的线程函数：\n\n```jsx showLineNumbers\nvoid *thread_pool_main(void *arg)\n{\n\tstruct thread_pool *pool = (struct thread_pool *) arg;\n\tstruct task *task;\n\n\twhile (1) {\n\t\t// 访问任务队列前加锁，为防止取消后死锁，注册处理例程 handle\n\t\tpthread_cleanup_push(handler, (void *)&pool->lock);\t//防止死锁\n\t\t// 获取锁\n\t\tpthread_mutex_lock(&pool->lock);\n\n\t\t// 如果任务队列为空，则阻塞等待\n\t\twhile (list_empty(&pool->queue) && !pool->shutdown) {\n\t\t\tpthread_cond_wait(&pool->cond, &pool->lock);\n\t\t}\n\n\t\t//如果任务为空，线程池被销毁，则立即释放互斥锁并退出\n\t\tif(list_empty(&pool->queue) && pool->shutdown) {\n\t\t\tpthread_mutex_unlock(&pool->lock);\n\t\t\tpthread_exit(NULL);\n\t\t}\n\n\t\t// 将队列中的第一个任务取出\n\t\ttask = list_first_entry(&pool->queue, struct task, list);\n\t\tlist_del(&task->list);\n\t\tpool->waiting_tasks--;\t// 任务数量减1\n\t\t// 释放锁\n\t\tpthread_mutex_unlock(&pool->lock);\n\t\t// 任务取走，解锁，并弹栈 handle（但不执行它）\n\t\tpthread_cleanup_pop(0);\n\n\t\t//执行任务期间拒绝取消请求\n\t\tpthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);\n\t\ttask->func(task->arg);\t// 执行任务\n\t\tpthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n\n\t\tfree(task);\t//释放资源\n\t}\n\tpthread_exit(NULL);\n}\n```\n\n+ 注册死锁处理函数\n\n```jsx showLineNumbers\nstatic void handler(void *arg)\n{\n\t// 响应取消请求之后自动处理：释放互斥锁\n\tpthread_mutex_unlock((pthread_mutex_t *)arg);\n}\n```\n\n\n\n## 3. 使用示例\n\n```jsx showLineNumbers\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include \"thread_pool.h\"\n\n// 任务1\nvoid *task(void *arg)\n{\n    printf(\"Task 1 is running...\\n\");\n\n    // 任务1休眠一段时间\n    sleep(1);\n\n    printf(\"Task 1 is done.\\n\");\n\n    //pthread_exit(NULL);\n}\n\nint main(int argc, char *argv[])\n{\n    // 创建线程池\n    struct thread_pool pool;\n    thread_pool_init(&pool, 4);\nprintf(\"当前线程数为：%u\\n\", pool.active_threads);\n\tsleep(1);\n\n\t// 删除线程\n\tthread_pool_remove_thread(&pool, 2);\nprintf(\"当前线程数为：%u\\n\", pool.active_threads);\n\tsleep(1);\n\n\t// 添加线程到线程池中\n\tthread_pool_add_thread(&pool, 3);\nprintf(\"当前线程数为：%u\\n\", pool.active_threads);\n\tsleep(1);\n\n    // 添加任务到线程池中\n    thread_pool_add_task(&pool, task, NULL);\n\tsleep(1);\n    thread_pool_add_task(&pool, task, NULL);\n\tsleep(1);\n    thread_pool_add_task(&pool, task, NULL);\n\tsleep(1);\n\n    // 主线程休眠一段时间，让任务完成\n    sleep(1);\nprintf(\"\\033[31m\"\"---------Function: [%s]---------Line: [%d]---------\\n\"\"\\033[m\", __FUNCTION__, __LINE__);\t\n    // 清理线程池\n    thread_pool_destroy(&pool);\n\nprintf(\"\\033[31m\"\"---------Function: [%s]---------Line: [%d]---------\\n\"\"\\033[m\", __FUNCTION__, __LINE__);\n\n    return 0;\n}\n```\n\n## 4. 源码\n\n想要源码的话，不妨上我的[🍍GitHub](https://github.com/disnox/thread_pool)看看吧！\n\n<!-- truncate -->"
        },
        {
          "id": "/blog_write",
          "metadata": {
            "permalink": "/blog/blog_write",
            "editUrl": "https://github.com/disnox/blog/edit/main/blog/project/1. 我为什么要写博客.md",
            "source": "@site/blog/project/1. 我为什么要写博客.md",
            "title": "我为什么要写博客",
            "description": "写博客",
            "date": "2022-10-25T00:00:00.000Z",
            "formattedDate": "2022年10月25日",
            "tags": [
              {
                "label": "blog",
                "permalink": "/blog/tags/blog"
              },
              {
                "label": "随笔",
                "permalink": "/blog/tags/随笔"
              },
              {
                "label": "docusaurus",
                "permalink": "/blog/tags/docusaurus"
              }
            ],
            "readingTime": 3.4966666666666666,
            "hasTruncateMarker": true,
            "authors": [
              {
                "name": "📺尚宇",
                "title": "嵌入式 / 学生",
                "url": "https://github.com/disnox",
                "imageURL": "/img/logo.webp",
                "key": "disnox"
              }
            ],
            "frontMatter": {
              "slug": "/blog_write",
              "title": "我为什么要写博客",
              "date": "2022-10-25T00:00:00.000Z",
              "authors": "disnox",
              "tags": [
                "blog",
                "随笔",
                "docusaurus"
              ],
              "keywords": [
                "blog",
                "随笔",
                "docusaurus"
              ],
              "description": "写博客",
              "image": "/img/blog/blog.png",
              "sticky": 4
            },
            "unlisted": false,
            "prevItem": {
              "title": "内核链表创建线程池",
              "permalink": "/blog/thread_pool2"
            }
          },
          "content": "我为什么要写博客？\n\n写博客的初衷是什么？\n\n写博客能给我带来什么？\n\n<!-- truncate -->\n\n## 前言\n\n第一次接触写博客的时候在去年9月份的时候，当时自己也在CSDN上写了几篇文章，第一次接触到**Markdown**语法，但是后面就因为各种各样的情况导致没有坚持下来，但当时学习的**Markdown**语法至今我还在使用。然后第一次接触自己搭建网页去写博客是今年5月份的时候，我的一个保研的师兄教我用  [**Docusaurus**](https://www.docusaurus.cn/docs/installation) 加 **Vercel** 部署去搭建属于自己的一个网站，风格主题都可以自己去自由的搭配，这点我是特别喜欢的，但当时一直忙着比赛，被压榨的实习工作导致自己没有去好好维护。当我决定好好沉淀一下自己，把自己所学、所看、所经历记录下来，已经快今年10月底了，还好还不晚。\n\n## 为什么写博客\n\n其实这些原因很简单。\n\n### 巩固学习、记录笔记\n\n走技术开发这条路，要学习的东西真的很多很多，然而人的记忆有限的，如果不按时的进行总结、记录，回过头再看其实跟重新学习没什么两样。这些我深有感触，我几个月不去观看维护的代码，做过的项目，我再去翻看的时候，有时候真的不亚于是在旁观一个别人做的项目，我有时候真的会要去重新理解。我觉得这样其实是一个很浪费时间的事情。我需要将这些项目的代码框图、设计思路给记录下来，以便下次查看。\n\n而且学习对我来说应该是一个搬运的过程，别人的笔记，别人的心得终究是别人的，只有我自己去记录去总结，有自己的框架，自己的思路那才是我的。而且不是所有的知识点都能记在脑子里面的，整理成册也是方便自己查找。而且写笔记也是对自己学习的一个梳理过程，提升自己的思维能力。\n\n### 学习交流，知识分享\n\n帮助他人，其实也是帮助自己，分享自己的笔记，记录自己的踩坑就是希望同样踩到这个坑的人可以看到。而且一个人的能力是有限的，我自己写出来的博客笔记也不可能十全十美，也许我自己检查个几遍都发现不了错误，而给别人看可能一下子就发现了，我希望通过这个博客去跟其他人进行一个交流，更加的去完善自己。\n\n## 为什么要搭建自己的小站呢？\n\n其实网上写博客的地方很多，像**CSDN**、**知乎**、**博客园**、**微博**等等，用来记录自己的学习生活、笔记也是完全够用的，但这些地方的文章、模板主题不全都是我喜欢的风格，但一些前端大佬（峰华、尚宇）他们做的网页博客真的是惊艳到我了，也是基于**Docusaurus**去搭建的。所以便拿来copy更改了一份自己的网页，当然我也很注重开源精神，已经征得原作者许可啦。当然我也不是学前端的，而是走的嵌入式开发，所以很多地方也只是照着模板修修改改，但 **CV** 这一方面我一直是在行的，而且效果真的挺好的，美观程度真的很影响学习状态，一个漂亮的网站让我写笔记都添加了不少动力，而且分栏分类都很不错。\n\n## 总结\n\n我在我的小站里面放了博客、技术笔记、工具推荐、还有网址导航，方便自己随时查阅、随时跳转。好看的小站固然重要，但最重要的还是技术的分享，最后，希望我分享的技术笔记，个人经历能对你有所启发。"
        }
      ],
      "tags": {
        "/blog/tags/c-c": {
          "label": "C/C++",
          "items": [
            "/classic",
            "/thread_pool1",
            "/thread_pool2"
          ],
          "permalink": "/blog/tags/c-c",
          "pages": [
            {
              "items": [
                "/classic",
                "/thread_pool1",
                "/thread_pool2"
              ],
              "metadata": {
                "permalink": "/blog/tags/c-c",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 3,
                "blogDescription": "尚宇的个人博客",
                "blogTitle": "Blog"
              }
            }
          ],
          "unlisted": false
        },
        "/blog/tags/exam": {
          "label": "exam",
          "items": [
            "/classic"
          ],
          "permalink": "/blog/tags/exam",
          "pages": [
            {
              "items": [
                "/classic"
              ],
              "metadata": {
                "permalink": "/blog/tags/exam",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "尚宇的个人博客",
                "blogTitle": "Blog"
              }
            }
          ],
          "unlisted": false
        },
        "/blog/tags/linux": {
          "label": "Linux",
          "items": [
            "/thread_pool1",
            "/thread_pool2"
          ],
          "permalink": "/blog/tags/linux",
          "pages": [
            {
              "items": [
                "/thread_pool1",
                "/thread_pool2"
              ],
              "metadata": {
                "permalink": "/blog/tags/linux",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 2,
                "blogDescription": "尚宇的个人博客",
                "blogTitle": "Blog"
              }
            }
          ],
          "unlisted": false
        },
        "/blog/tags/blog": {
          "label": "blog",
          "items": [
            "/blog_write"
          ],
          "permalink": "/blog/tags/blog",
          "pages": [
            {
              "items": [
                "/blog_write"
              ],
              "metadata": {
                "permalink": "/blog/tags/blog",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "尚宇的个人博客",
                "blogTitle": "Blog"
              }
            }
          ],
          "unlisted": false
        },
        "/blog/tags/随笔": {
          "label": "随笔",
          "items": [
            "/blog_write"
          ],
          "permalink": "/blog/tags/随笔",
          "pages": [
            {
              "items": [
                "/blog_write"
              ],
              "metadata": {
                "permalink": "/blog/tags/随笔",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "尚宇的个人博客",
                "blogTitle": "Blog"
              }
            }
          ],
          "unlisted": false
        },
        "/blog/tags/docusaurus": {
          "label": "docusaurus",
          "items": [
            "/blog_write"
          ],
          "permalink": "/blog/tags/docusaurus",
          "pages": [
            {
              "items": [
                "/blog_write"
              ],
              "metadata": {
                "permalink": "/blog/tags/docusaurus",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "尚宇的个人博客",
                "blogTitle": "Blog"
              }
            }
          ],
          "unlisted": false
        }
      }
    }
  }
}