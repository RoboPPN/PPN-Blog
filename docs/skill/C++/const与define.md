## const 与 `#define`

1、const的作用是让某值保持不变，不可修改该值

2、C++中的const变量虽然也会占用内存，也能使用&获取它的地址，但在使用时更像编译时期的#define。 #define也是值替换，可见范围也仅限于当前文件。

3、但是，#define定义的常亮仅仅是字符串的替换，不会进行类型检查，而const定义的变量是会让编译器进行类型检查的，相比于#define更安全。

4、墙裂建议使用const代替#define宏定义

使用`const`关键字具有以下优势：

1. **类型安全**：`const`关键字提供了类型安全性，编译器可以对常量进行类型检查，并确保其值与定义的类型匹配。相比之下，使用宏定义时没有类型检查，可能会导致潜在的错误。
2. **作用域限制**：`const`常量受限于其定义的作用域。它们可以在特定的作用域内访问，并且不会在其他作用域中引起命名冲突。而宏定义则没有这样的限制，它们在整个文件中都是可见的。
3. **符号表信息**：使用`const`关键字定义的常量在符号表中会有对应的信息，包括名称和类型。这对于调试和代码理解非常有帮助。而宏定义只是简单地进行文本替换，没有符号表信息。

代码示例：

```cpp
#define N 100
const int N = 100
```

在C++中，按引用传递参数时，使用const关键字可以将参数声明为"const引用"。这意味着在函数中无法修改该参数的值。以下是将参数声明为const引用的好处：

1. 避免无意的修改：const关键字确保函数内部不会无意间修改传入的参数的值。这可以帮助预防程序中的错误，特别是当参数被多个函数使用时。
2. 安全性和可维护性：使用const可以增加代码的可读性和可维护性。通过在函数声明中指定参数为const引用，可以清晰地表明函数不会修改该参数的值。这使得代码更易于理解，并且在后续的代码维护和调试过程中更容易追踪参数的用法。
3. 支持传递临时对象：当传递临时对象（例如，函数返回的临时对象）作为引用参数时，将其声明为const引用是必要的，因为临时对象无法被非const引用所绑定。
4. 优化性能：使用const引用作为参数可以避免不必要的复制。如果参数不是const引用，而是普通的非const引用，那么在函数调用时，编译器将创建参数的副本。而使用const引用则可以避免这种复制开销。
