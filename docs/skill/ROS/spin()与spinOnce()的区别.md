## ros消息回调处理函数ros::spin()与ros::spinOnce()的区别

**消息回调函数处理机制：接收订阅消息时，接收到的消息并不是立刻就处理，而是将传入的消息存入到队列中，必须要等到ros::spin()或ros::spinOnce()执行的时候才被调用，这就是消息回调函数的原理。**

消息订阅器一旦知道话题里面有消息到达，就会将消息作为参数传入callback函数中，但是此时还没有执行callback函数，而是把callback函数放到了回调函数队列中。所以当发布者不断发送消息到话题上面时，就会有相应的callback函数进入队列中，它们函数名一样，只是实参不一样。

那么什么时候才会执行callback函数呢？那就是ros::spin()和ros::spinOnce()的事了。

当spinOnce函数被调用时，spinOnce就会调用回调函数队列中第一个callback函数，此时callback函数才会被执行，然后等到下次spinOnce函数又被调用时，回调函数队列中第二个callback函数就会被调用，以此类推。

所以，这会有一个问题。因为回调函数队列的长度是有限的，如果发布者发送的数据太快，spinOnce函数调用的频率太少，就会导致对列溢出，一些callback函数就会被挤掉，导致没被执行到。

而对于spin函数，一旦进入spin函数，它就不会返回了，相对于它在自己的函数里面死循环了。只要回调函数里面有callback函数在，它就会马上去执行callback函数。如果没有的话，它就会阻塞，不会占用CPU。


两者的区别在于

1. ros::spin()调用后程序就不往下执行，一直在调用。ros::spin()函数一般不会出现在循环中，因为程序执行到spin()后就不调用其他语句了，也就是说该循环没有任何意义，还有就是spin()函数后面一定不能有其他语句(return 0 除外)，有也是白搭，不会执行的。

2. 而ros::spinOnce()调用后还可以执行下面的程序，只调用一次（如果还想调用，那就要加上循环了）。


如果程序写了相关的消息订阅函数，千万别忘了在相应的位置上加上`ros::spin()`或者`ros::spinOnce()`函数,不然就会永远得不到另一边发出的数据消息。
