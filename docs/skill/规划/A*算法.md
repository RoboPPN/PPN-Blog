## 什么是A*算法？

A* 算法是一种规划路径的算法，常用于在地图上寻找最优路径。它的工作原理是通过不断扩展最优点，来最终找到终点的最优路径。

A*算法使用了启发式搜索策略，即在搜索时会考虑最终目标的位置，并计算出每个点到终点的估价距离（称为启发函数）。这样，在搜索过程中，A* 算法就可以比较出目前已经搜索到的点和当前扩展点之间的最优解，并选择最优的一条路径进行扩展。这样，A* 算法就能够有效地避免搜索不必要的点，从而节省时间和空间。

A*算法的时间复杂度和空间复杂度取决于启发函数的选择。如果选择的启发函数是最优的，那么 A* 算法的时间复杂度和空间复杂度就是最优的。

### 启发函数介绍

在A*算法里有这么一条公式：

> f(n) = g(n) + h(n)

其中g(n)是当前点到起点的实际代价，可以通过计算每个节点间的距离来确定，h(n)是当前点到终点的估计代价，这个值可以通过启发函数来计算。

A算法中的启发式函数(heuristic function)是一种估计函数，用来估算从当前节点到终点的估计代价。在A算法中，估计代价h(n)是通过启发式函数来确定的。

如果启发式函数恰好等于终点到当前节点的实际代价，那么A算法就会等价于Dijkstra算法，而如果启发式函数为0，A算法就等价于广度优先搜索算法。

算法会按照f(n)的值从小到大搜索节点。 在每一次搜索时优先搜索f(n)值最小的节点，并不断更新最优路径。因此A算法能够在有效的时间内找到最短路径。
在给定的图形中，A*算法每次都会将f(n)值最小的点作为当前节点检查。这样可以保证找到的路径一定是最短路径。
算法会不断重复检查周围节点直到找到终点。

### A*算法如何选择启发函数

常用的启发函数有两种：曼哈顿距离和欧几里得距离。

通常的,启发式函数通过曼哈顿距离、欧几里得距离或者其他的距离公式来计算当前节点和终点之间的估计距离。 一般来说，启发式函数越精确算法会更快找到最优解，但会增加算法复杂度和计算量。

曼哈顿距离是指两点在平面直角坐标系中的距离，计算公式如下：

d = |x1 - x2| + |y1 - y2|

欧几里得距离是指两点在n维空间中的距离，计算公式如下：

d = sqrt((x1 - x2)^2 + (y1 - y2)^2 + ... + (n1 - n2)^2)

A*算法的启发函数是用来计算当前点到终点的估价距离，从而决定搜索哪些点是最有可能的最优解。启发函数的选择对于 A* 算法的性能有很大的影响。

在选择启发函数时，需要考虑地图的特征以及搜索的精度要求。如果地图是平面直角坐标系，且对搜索精度要求较低，那么可以使用曼哈顿距离；如果地图是n维空间，或者对搜索精度要求较高，则可以使用欧几里得距离。

需要注意的是，启发函数只是估价函数，不一定是真实的距离。因此，选择合适的启发函数是很重要的，它直接影响 A* 算法的性能。

## A*算法实现过程

### 简易地图

![img error](https://uploads.gamedev.net/monthly_2018_05/aStarT1.jpg.d75d82a7b81262ca3d882353c92d0f51.jpg)

 如图所示简易地图, 其中绿色方块的是起点 (用 A 表示), 中间蓝色的是障碍物, 红色的方块 (用 B 表示) 是目的地. 为了可以用一个二维数组来表示地图, 我们将地图划分成一个个的小方块。

二维数组在游戏中的应用是很多的, 比如贪吃蛇和俄罗斯方块基本原理就是移动方块而已。而大型游戏的地图, 则是将各种"地貌"铺在这样的小方块上。

### 寻路步骤

1. **从起点A开始, 把它作为待处理的方格存入一个`开启列表`, 开启列表就是一个等待检查方格的列表**；

2. **寻找起点A周围可以到达的方格, 将它们放入"开启列表", 并设置它们的`父方格`为A**；

3. **从"开启列表"中删除起点 A, 并将起点 A 加入`关闭列表`, "关闭列表"中存放的都是不需要再次检查的方格**；

![img error](https://uploads.gamedev.net/monthly_2018_05/aStarT2.jpg.461d6c92a13dad908f94279636ba18d8.jpg)

图中浅绿色描边的方块表示已经加入 "开启列表" 等待检查。淡蓝色描边的起点 A 表示已经放入 "关闭列表" , 它不需要再执行检查。

从 "开启列表" 中找出相对最靠谱的方块, 什么是最靠谱? 它们通过公式`F=G+H`来计算。
:::tip  启发函数
 F = G + H

G 表示从起点 A 移动到网格上指定方格的移动耗费 (可沿斜方向移动)。

H 表示从指定的方格移动到终点 B 的预计耗费 (H 有很多计算方法,这里我们使用的是曼哈顿法,计算从当前方格到目标方格的水平和垂直移动的方格总数)。
:::

![img error](https://uploads.gamedev.net/monthly_2018_05/aStarT4.jpg.64a6f6ac621b0af7e11f4964ad668c51.jpg)

我们假设横向移动一个格子的耗费为10, 为了便于计算, 沿斜方向移动一个格子耗费是14(因为对角移动的实际距离是 2 的平方根,大约是水平或垂直移动成本的 1.414 倍)。为了更直观的展示如何运算`FGH`, 图中方块的左上角数字表示 F, 左下角表示 G, 右下角表示 H 。看看是否跟你心里想的结果一样?

从 `开启列表` 中选择 F 值最低的方格 C (绿色起始方块 A 右边的方块), 然后对它进行如下处理:

4. **把它从 "开启列表" 中删除, 并放到 "关闭列表" 中**

5. **检查它所有相邻并且可以到达 (障碍物和 "关闭列表" 的方格都不考虑) 的方格。 如果这些方格还不在 "开启列表" 里的话, 将它们加入 "开启列表", 计算这些方格的 G, H 和 F 值各是多少, 并设置它们的 "父方格" 为 C**

6. **如果某个相邻方格 D 已经在 "开启列表" 里了, 检查如果用新的路径 (就是经过C 的路径) 到达它的话, G值是否会更低一些, 如果新的G值更低, 那就把它的 "父方格" 改为目前选中的方格 C, 然后重新计算它的 F 值和 G 值 (H 值不需要重新计算, 因为对于每个方块, H 值是不变的)。 如果新的 G 值比较高, 就说明经过 C 再到达 D 不是一个明智的选择, 因为它需要更远的路, 这时我们什么也不做**

![img error](https://uploads.gamedev.net/monthly_2018_05/aStarT4.jpg.64a6f6ac621b0af7e11f4964ad668c51.jpg)

如图, 我们选中了 C 因为它的 F 值最小, 我们把它从 "开启列表" 中删除, 并把它加入 "关闭列表"。 它右边上下三个都是墙, 所以不考虑它们。 它左边是起始方块, 已经加入到 "关闭列表" 了, 也不考虑。 所以它周围的候选方块就只剩下 4 个。 让我们来看看 C 下面的那个格子, 它目前的 G 是14, 如果通过 C 到达它的话, G将会是 10 + 10, 这比 14 要大, 因此我们什么也不做。

然后我们继续从 "开启列表" 中找出 F 值最小的, 但我们发现 C 上面的和下面的同时为 54, 这时怎么办呢? 这时随便取哪一个都行, 比如我们选择了 C 下面的那个方块 D。

![img error](https://uploads.gamedev.net/monthly_2018_05/aStarT5.jpg.b2beeb270ef7f5f9603f26314775b3e1.jpg)

D 右边已经右上方的都是墙, 所以不考虑, 但为什么右下角的没有被加进 "开启列表" 呢? 因为如果 C 下面的那块也不可以走, 想要到达 C 右下角的方块就需要从 "方块的角" 走了, 在程序中设置是否允许这样走(图中的示例不允许这样走)。

![img error](https://uploads.gamedev.net/monthly_2018_05/aStarT6.jpg.6e5cfc9835e70946962cf18c74f90616.jpg)

就这样, 我们从 "开启列表" 找出 F 值最小的, 将它从 "开启列表" 中移掉, 添加到 "关闭列表"。再继续找出它周围可以到达的方块, 如此循环下去...

那么什么时候停止呢? —— 当我们发现 "开始列表" 里出现了目标终点方块的时候, 说明路径已经被找到。

### 如何找回路径

![img error](https://uploads.gamedev.net/monthly_2018_05/aStarT7.jpg.fd4f9bf6c302cb5b554b7c98ab9296ee.jpg)

如上图所示, 除了起始方块, 每一个曾经或者现在还在 "开启列表" 里的方块, 它都有一个 "父方块", 通过 "父方块" 可以索引到最初的 "起始方块", 这就是路径。

### 将整个过程抽象

1. 将其从打开列表中删除并将其添加到关闭列表中；
2. 检查所有相邻的方块。忽略那些在封闭列表中或无法行走的（有墙、水或其他非法地形的地形），如果它们不在开放列表中，则将它们添加到开放列表中。使所选方块成为新方块的“父”；
3. 如果相邻方格已在打开列表中，请检查通往该方格的这条路径是否更好。换句话说，如果我们使用当前方块到达那里，检查该方块的 G 分数是否较低。如果没有，请不要做任何事情；
另一方面，如果新路径的 G 成本较低，则将相邻方块的父级更改为所选方块（在上图中，将指针的方向更改为指向所选方块）。最后，重新计算该方块的 F 和 G 分数。如果这看起来令人困惑，您将在下面看到它；
4. 将起始方块（或节点）添加到打开列表中；
5. 重复以下操作：

- a) 在打开的列表中寻找最低的 F 成本方。我们将其称为当前方块。

- b) 将其切换到关闭列表。

- c) 对于与当前方格相邻的 8 个方格中的每一个......
  - 如果它不可步行或在封闭列表中，请忽略它。否则执行以下操作。
  - 如果它不在打开列表中，请将其添加到打开列表中。使当前方块成为这个方块的父方块。记录正方形的 F、G 和 H 成本。
  - 如果它已经在 open list 上，检查这条通往那个方块的路径是否更好，使用 G 成本作为度量。较低的 G 成本意味着这是一条更好的路径。如果是，则将正方形的父级更改为当前正方形，并重新计算正方形的 G 和 F 分数。如果你保持你的开放列表按 F 分数排序，你可能需要使用列表来解释变化。
- 将目标方块添加到封闭列表中，在这种情况下，路径已经找到（见下面的注释），或
- 找不到目标方格，打开列表为空。在这种情况下，没有路径。
- 保存路径。从目标方格向后工作，从每个方格到其父方格，直到到达起始方格。那是你的道路。注意：在本文的早期版本中，建议您可以在目标方格（或节点）已添加到打开列表而不是关闭列表时停止。这样做会更快，并且几乎总是会给你最短的路径，但并非总是如此。这样做可能会产生影响的情况是，从第二个节点到最后一个节点再到最后一个（目标）节点的移动成本可能会发生显着变化——例如，在两个节点之间的河流穿越的情况下。

```cpp
把起始格添加到 "开启列表" 
do 
{ 
        寻找开启列表中F值最低的格子, 我们称它为当前格。
        把它切换到关闭列表。
        对当前格相邻的8格中的每一个 
        if (它不可通过 || 已经在 "关闭列表" 中) 
        { 
                什么也不做。 
        } 
        if (它不在开启列表中) 
        { 
                把它添加进 "开启列表", 把当前格作为这一格的父节点, 计算这一格的 FGH 
        }
        if (它已经在开启列表中) 
        { 
                if (用 G 值为参考检查新的路径是否更好, 更低的G值意味着更好的路径) 
                { 
                        把这一格的父节点改成当前格, 并且重新计算这一格的 GF 值。 
                } 
        }
} while( 目标格已经在 "开启列表", 这时候路径被找到) 
如果开启列表已经空了, 说明路径不存在。
```

## A*算法的优缺点

优点：

- 算法具有高效性，一般能在可接受的时间内找到最短路径；
- 可以保证找到的路径一定是最优解。即对于任意两个结点，它们之间的实际距离不会大于启发函数估算出的距离， 那么A*算法所找到的路径就是最优解。
- 适用于多种场景，如自动导航、游戏AI等。

缺点：

- 算法复杂度较高，随着问题规模的增大而增大；
- 对精确的启发式函数要求较高，如果估计代价不准确可能导致算法性能下降；
- 在处理稠密图的时候，空间开销和复杂度会很大，算法性能会降低；
- 需要一些预处理，对于动态图需要重新搜索。

### 对精确的启发式函数要求较高，如果估计代价不准确可能导致算法性能下降

A*算法的估计代价h(n)是通过启发式函数来确定的，而启发式函数是通过当前节点和终点之间的估计距离来计算的。当估计代价h(n)不准确时，可能会导致算法选择了错误的路径，使得搜索时间增加。

假设现在有一个地图，A算法从起点开始搜索，当前节点为A，终点为B。在A点和B点之间有两条路径，一条是直接从A到B，另一条是从A经过C点再到B。如果估计函数估算出A点到B点的距离很大，那么A算法会认为经过C点的路径更优，因为它的f(n)值会更小。但实际上A点到B点的距离并不大，经过C点的路径实际上并不优。由于估计代价不准确，算法选择了错误的路径，导致搜索时间增加。

因此精确的启发式函数要求较高，如果估计代价不准确，可能会导致算法选择错误的路径，导致搜索时间增加从而导致算法性能下降。

总之,算法的估计代价是否准确直接影响到算法搜索到最优解的效率，如果启发式函数不够精确，A*算法可能会在较长时间内搜索到解或者甚至无法找到最优解，导致算法性能下降。

因此，选择和设计合适的启发式函数是非常重要的。在不同的场景中有不同的启发式函数, 例如：

- 在网格地图导航中，可以使用曼哈顿距离作为启发式函数，因为这种距离只考虑水平和垂直方向上的距离，符合在网格地图中行走的特点。
- 在机器人导航中，可以使用欧几里得距离作为启发式函数，因为它考虑了机器人在三维空间中行走的特点。
- 在计算机视觉中, 对于图像搜索，可以使用余弦相似性作为启发式函数来估算相似度。
- 在高维空间中的其他问题，比如计算化学分子之间的距离，可能需要研究者根据具体问题自己设计合适的启发式函数。

### 需要一些预处理，对于动态图需要重新搜索

预处理指的是在算法运行之前，对图的某些部分进行处理以提高算法的效率。这些预处理操作可以是在图中预先计算出最短路径，或者预先计算出点到点的最短路径等。

预处理的目的是为了让算法能够在最短时间内找到最优解，而不需要重复计算已知信息。预处理可以大大减少算法所需要的运算次数。

而对于动态图，状态是不断变化的，预处理的信息可能已经过时了。所以需要重新搜索，重新计算最优解。

比如对于一个交通图，路况可能会经常变化，如果有交通管制或者道路建设等原因导致某些边不能通行了，或者边的权重变化，就需要重新搜索来获取最新的最短路径。

## A*优化

A*算法可以从以下几个方面进行优化:

1. 启发式函数优化：对于不同的场景选择合适的启发式函数，通过减少不必要的搜索可以提高算法的效率。

2. 剪枝优化：使用启发式函数剪枝可以避免对于不可能到达目标结点的结点进行搜索，提高算法的效率。

3. 空间优化：使用哈希表或者其他数据结构可以降低空间复杂度。

4. 使用估价函数的历史信息优化：通过使用经过结点的历史信息可以减少重复的状态。

   使用估价函数的历史信息优化可以通过记录之前经过的结点的信息来减少重复的状态。例如,当寻找从起点到终点的最短路径时,在搜索过程中记录每个结点的g(n)和h(n)值,可以使用这些信息来避免对相同的结点进行重复的计算。

5. 对于稠密图， 使用多线程或分布式计算能够加速算法的搜索过程。

## A*获取周围8个相邻点示例代码

```cpp
class AStarPlanner {
    // The width and height of the gridmap
    int width, height;
    // Get neighbors of a certain node, stored in neighbors_index
    void GetEightNeighbors(const int &current_index, std::vector<int> &neighbors_index) const {
        neighbors_index.clear();
        int x = current_index % width; //当前点在图像上的横坐标，当current_index为0,1,2,3,4 在 5*5 的地图上， x 值分别为 0,1,2,3,4
        int y = current_index / width; //当前点在图像上的纵坐标，当current_index为0,5,10,15,20 在 5*5 的地图上， y 值分别为 0,1,2,3,4
        // check up
        if (y - 1 >= 0) {
            neighbors_index.push_back(current_index - width);
        }
        // check left
        if (x - 1 >= 0) {
            neighbors_index.push_back(current_index - 1);
        }
        // check down
        if (y + 1 < height) {
            neighbors_index.push_back(current_index + width);
        }
        // check right
        if (x + 1 < width) {
            neighbors_index.push_back(current_index + 1);
        }
        // check left-up
        if (x-1 >= 0 && y-1 >= 0) {
            neighbors_index.push_back(current_index - width - 1);
        }
        // check left-down
        if (x-1 >= 0 && y+1 < height) {
            neighbors_index.push_back(current_index + width - 1);
        }
        // check right-down
        if (x+1 < width && y+1 < height) {
            neighbors_index.push_back(current_index + width + 1);
        }
        // check right-up
        if (x+1 < width && y-1 >= 0) {
            neighbors_index.push_back(current_index - width + 1);
        }
        return;
    }
};
```

可以看到上面代码通过优化来降低空间复杂度，它通过使用在线计算x、y坐标来避免进行累加以及整除操作。使用8个if语句来分别判断每个相邻点是否在地图范围内，并且不是在地图边界上。这样可以避免对于越界结点进行搜索，减少了算法的时间复杂度。

## 参考致谢

[A* Pathfinding for Beginners](https://www.gamedev.net/articles/programming/artificial-intelligence/a-pathfinding-for-beginners-r2003/)

[理解A*寻路算法具体过程](https://www.cnblogs.com/technology/archive/2011/05/26/2058842.html)

[Introduction to A* Pathfinding](https://www.kodeco.com/3016-a-pathfinding-for-unity-2d-with-a-star-spatial-awareness)
